import cPickle as pickle
import gzip
import numpy as np

import pysces

from ..utils.plotting import Data2D


def do_vspans(ax, x, y, conditions, colors):
    """
    Applies various vspans to an ax depending on conditions set for the
    y values.

    Parameters
    ----------
    ax : ax
        The axis to apply vspans to.
    x : array like
        The x values.
    y : array like
        The y values.
    conditions : list
        List of conditions which y is checked against.
    colors : list
        The colors for the conditions.
    """
    for i, condition in enumerate(conditions):
        condarr = find_range(y, condition)
        range_pairs = get_range_pairs(x, condarr)
        set_axvspans(ax, range_pairs, colors[i])


def find_range(arr, cond):
    """
    Returns an array of booleans corresponding to values in `arr` that
    satisfies the str `cond`.
    """
    trues = eval('arr' + cond, {'arr': arr, 'cond': cond})
    return trues


def get_range_pairs(arr, condarr):
    """
    Returns values in arr which define the beginning and end points of
    sequential True values in `condarr` (as generated by `find_range`).
    """
    starts = []
    ends = []
    curr = False
    the_len = len(condarr)
    for i, cond in enumerate(condarr):
        if curr == False and cond == True:
            curr = True
            starts.append(arr[i])
        elif curr == True and cond == False:
            curr = False
            ends.append(arr[i - 1])
        elif curr == True and i + 1 == the_len:
            curr = False
            ends.append(arr[i])
    return zip(starts, ends)


def set_axvspans(ax, ranges, color):
    """
    For a list of two value tuples which define ranges, create a vspan
    with the color defined in `color`.
    """
    for rng in ranges:
        ax.axvspan(rng[0], rng[1], alpha=0.2, color=color)


def make_additionals(list_of_cats):
    """
    A hacky way of quickly creating both an `additional_cat_classes`
    dict and an `additional_cats` dict for use in instantiation of
    a `Data2D` object based on a list of "non standard" outputs.
    """
    return {'Other': ['Additional Lines']}, {'Additional Lines': list_of_cats}


def find_any_ma(mod, reaction_name):
    """
    Based on `reaction` in a model `mod` return a string of the name of
    any species of that reaction with the string "_ma" appended to it.
    This is used to find the index of an elasticity of a "mass action"
    term in a Data2d `scan_res.scan_out` list that is used to select the
    column representing the results of a scan for that elasticity term
    from `scan_results.scan_results`. (Elasticities of mass action terms
    towards all substrates and products are equivalent except in
    case of ratios).
    """
    mm = pysces.ModelMap(mod)
    reaction = getattr(mm, reaction_name)
    substrates = [subs + '_ma' for subs in reaction.hasSubstrates()]
    products = [prod + '_ma' for prod in reaction.hasProducts()]
    return {'substrates': substrates, 'products': products}


def save_data2d(data_2dobj, file_name):
    """
    Saves a Data2D object to a gzipped cPickle to a specified file name.
    """
    data_2dobj.mod = data_2dobj.mod.ModelFile
    with gzip.open(file_name, 'wb') as f:
        pickle.dump(data_2dobj, f)


def load_data2d(file_name, mod=None, ltxe=None):
    """
    Loads a gzipped cPickle file containing a Data2D object. Optionally
    a model can be provided (which is useful when loading data that
    reference the same model. For the same reason a LatexExpr object
    can be supplied.
    """
    with gzip.open(file_name, 'rb') as f:
        data_2dobj = pickle.load(f)
    if not mod:
        data_2dobj.mod = pysces.model(data_2dobj.mod)
    else:
        data_2dobj.mod = mod
    if ltxe:
        del data_2dobj._ltxe
        data_2dobj._ltxe = ltxe
    return data_2dobj


def generate_results(mod, tk, parameters, reactions, start=100, end=100,
                     scan_points=100):
    """
    Given a model, a thermokin object a list of parameters and a list
    of reactions, perform parameter scans for each parameter, reaction
    combination and return a dictionary with the structure
    dict[parameters][reactions][results] where results have the keys
    `data_1`, `plot_1`, `data_2` and `plot_2`. `data_1` is Data2D
    object  representing an elasticity scan of a reaction towards a
    parameter and `plot_1` is the corresponding ScanFig of the data.
    `data_2` is the gamma/keq values for the same range as `data_1`
    with its plot stored in `plot_2`
    """
    parameter_results = {}
    for parameter in parameters:
        parameter_results[parameter] = {}

        parameter_init = getattr(mod, parameter)
        scan_range = np.logspace(np.log10(parameter_init / start),
                                 np.log10(parameter_init * end),
                                 scan_points)
        for reaction in reactions:
            parameter_results[parameter][reaction] = {}
            data_1 = getattr(tk, 'J_' + reaction).do_par_scan(
                    parameter,
                    scan_range,
                    scan_type='elasticity')

            optionals = {'mod': mod,
                         'parameter': parameter,
                         'scan_range': scan_range,
                         'parameter_init': parameter_init,
                         'reaction': reaction}

            plot_1, data_2, plot_2 = rest_from_data_1(data_1,
                                                      optionals=optionals)

            parameter_results[parameter][reaction]['data_1'] = data_1
            parameter_results[parameter][reaction]['plot_1'] = plot_1
            parameter_results[parameter][reaction]['data_2'] = data_2
            parameter_results[parameter][reaction]['plot_2'] = plot_2

    return parameter_results


def rest_from_data_1(data_1, optionals=None):
    """
    Generates `plot_1`, `data_2` and `plot_2` from a `data_1` as
    defined in generate_results.
    """
    if not optionals:
        mod = data_1.mod
        parameter = data_1.scan_results.scan_in
        scan_range = data_1.scan_results.scan_range
        parameter_init = getattr(mod, parameter)
        reaction = scan_out_reaction(data_1.scan_results.scan_out,
                                     mod.parameters)
    else:
        mod = optionals['mod']
        parameter = optionals['parameter']
        scan_range = optionals['scan_range']
        parameter_init = optionals['parameter_init']
        reaction = optionals['reaction']

    species_type = None
    for k, v in find_any_ma(mod, reaction).iteritems():
        for species in v:
            try:
                ma_term_index = data_1.scan_results.scan_out.index(
                    'pec%s_%s' % (
                        reaction,
                        species))
                species_type = k
                break
            except:
                pass
        if species_type: break

    plot_1 = data_1.plot()
    plot_1.ax.set_ylim(-1, 5)

    x = scan_range
    y1 = data_1.scan_results.scan_results[:, ma_term_index]

    if species_type == 'substrates':
        y2 = -((1 / y1) - 1)
    elif species_type == 'products':
        y2 = (-1 / (1 / y1 - 1))

    do_vspans(plot_1.ax, x, y2, ['<=0.1', '>=0.9'], ['green', 'blue', ])
    plot_1.ax.axvline(parameter_init, ls=':', color='gray')
    plot_1.toggle_category('Elasticity Coefficients', True)
    plot_1.toggle_category('Term Elasticities', True)

    a1, a2 = make_additionals(['GammaKeq'])
    data_2 = Data2D(mod,
                    [parameter, 'GammaKeq'],
                    np.vstack(
                            [scan_range, y2]).transpose(),
                    ax_properties={'xscale': 'log',
                                   'xlim': (scan_range[0],
                                            scan_range[-1]),
                                   'ylim': (0, 1),
                                   'xlabel': parameter,
                                   'ylabel': '$\\Gamma/K_{eq}$'},
                    additional_cat_classes=a1,
                    additional_cats=a2,
                    ltxe=data_1._ltxe)
    plot_2 = data_2.plot()
    plot_2.ax.axvline(parameter_init, ls=':', color='gray')
    plot_2.toggle_category('Additional Lines', True)
    plot_2.toggle_category('GammaKeq', True)
    do_vspans(plot_2.ax, x, y2, ['<=0.1', '>=0.9'], ['green', 'blue', ])
    return plot_1, data_2, plot_2


def scan_out_reaction(scan_out, parameters):
    """
    Gets the reaction for which a parameter scan was performed from a
    list of elasticity and "partial" elasticity scans and a list of
    model parameters.
    """
    ecs = []
    for each in scan_out:
        if each.startswith('ec'):
            ecs.append(each)
    reaction = None
    for ec in ecs:
        for param in parameters:
            pl = len(param)
            if ec[-pl:] == param:
                if not reaction:
                    reaction = ec[2:-pl - 1]
                elif len(ec[2:-pl - 1]) < reaction:
                    reaction = ec[2:-pl - 1]
    return reaction
